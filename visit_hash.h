#ifndef VISIT_HASH_H
#define VISIT_HASH_H

// -------------------- Loop Detection: visited directories linked list --------------------
// Stores inode/device ID pairs of all directories that have been successfully entered.
// Used to detect and avoid infinite loops when following symlinks.

void create_visited_node_hash();
void free_visited_node_hash();
int add_visited(dev_t dev, ino_t ino);
bool visited_before(dev_t dev, ino_t ino);

#endif  

/*
 * khashl.h (r36) Function Cheat Sheet
 *
 * NOTE: This assumes the hash table is initialized with a prefix like 'kh'.
 * e.g., KHASHL_MAP_INIT(..., kh, ...) creates kh_init, kh_get, etc.
 *
 * The KHASHL_MAP_INIT and KHASHL_SET_INIT macros generate functions
 * with the same name and signature, but their internal operation
 * and the structure they manage (map or set) differ.

 * -----------------------------------------------------------------------
 * TYPE DEFINITION AND INITIALIZATION
 * -----------------------------------------------------------------------
 *
 * Type Definition:
 * To define a map type (e.g., 'charmap' with KeyType khint64_t and ValueType unsigned char):
 * 1. typedef struct khash_NAME khash_NAME;
 * 2. KHASHL_MAP_INIT(static kh_inline klib_unused, khash_NAME, kh, KType, VType, HashFn, EqualFn)
 * Parameters Explained (Example: KHASHL_MAP_INIT(..., khash_charmap, kh, khint64_t, unsigned char, kh_hash_uint64, kh_eq_generic)):
 * --------------------------------------------------------------------------------------------------------------------------------
 * SCOPE:      The scope of the generated functions. Typically 'static kh_inline klib_unused' to keep symbols local and permit inlining.
 * HType:      The **struct name** declared in step 1 (e.g., khash_charmap). This is the type a pointer must be declared as.
 * prefix:     The **function prefix** for all generated API calls (e.g., 'kh'). This must be unique across all KHASHL maps in the project.
 * KType:      The C type for the **key** (e.g., khint64_t).
 * VType:      The C type for the **value** (e.g., unsigned char).
 * HashFn:     The hash function macro/call, which must accept KType and return khint_t (provided functions are: kh_hash_uint64, kh_hash_uint32, kh_hash_str, kh_hash_bytes, kh_hash_dummy).
 * EqualFn:    The key equality comparison function, which must accept two KType variables and return true (non-zero) if they are equal (provided functions are: kh_eq_generic, kh_eq_str).
 *
 
// --------------------------------------------------------------------------
//                  COMMON FUNCTIONS (MAP and SET)
// --------------------------------------------------------------------------
// These functions are generated by both KHASHL_MAP_INIT and KHASHL_SET_INIT
// and perform the same core operations (init, free, resize, lookup, delete, clear).
//
// Function Signature:
//    HType* prefix_init(void);
//    HType* prefix_init2(void *km);
//    void prefix_destroy(HType *h);
//    void prefix_clear(HType *h);
//    void prefix_resize(HType *h, khint_t new_n_buckets);
//    khint_t prefix_get(const HType *h, khkey_t key);
//    khint_t prefix_put(HType *h, khkey_t key, int *absent);
//    int prefix_del(HType *h, khint_t k);

// Initialization and Deallocation 
kh_init             // Allocates and initializes a new hash table (with default allocator).
kh_init2            // Allocates and initializes a new hash table (with custom allocator 'km').
kh_destroy          // Frees all memory associated with the hash table (h).
kh_clear            // Clears all elements from the hash table (h) without freeing the memory.

// Maintenance and Sizing 
kh_resize           // Resizes the hash table to at least new_n_buckets capacity.

// Lookup and Insertion 
kh_get              // Looks up 'key'. Returns the index (khint_t k) if found, or kh_end(h) if not.
kh_put              // Inserts 'key'. Returns the index (khint_t k) of the new or existing slot.
                    // 'absent' is set to 1 if the key was new, 0 if it already existed.
                    // For maps, the value is set *after* calling kh_put using kh_val(h, k) = value.

// Deletion 
kh_del              // Deletes the element at index 'k' (typically returned by kh_get or kh_put).

// --------------------------------------------------------------------------
//                  SPECIFIC FUNCTIONS (MAP)
// --------------------------------------------------------------------------
// These functions are not generated but are MACROS that only make sense
// when used with a MAP (key-value pair) initialized with KHASHL_MAP_INIT.
// The underlying structure (h)->keys[x] has a '.val' member.

// Accessing Value for Maps (requires KHASHL_MAP_INIT) 
kh_val(h, x)        // Accesses the 'value' field of the bucket at index 'x'.
                    // e.g., kh_val(h, k) = 42; // Set value after put
                    // e.g., return kh_val(h, k); // Get value after successful get

// --------------------------------------------------------------------------
//                  SPECIFIC FUNCTIONS (SET)
// --------------------------------------------------------------------------
// No special functions are generated for sets. A set is functionally a map
// where the 'value' part of the bucket is ignored or not used in the public
// interface. The underlying structure (h)->keys[x] does NOT have a '.val'
// member for sets.

// --------------------------------------------------------------------------
//                  COMMON MACROS (MAP and SET)
// --------------------------------------------------------------------------
// These public macros work for both maps and sets.

kh_bucket(h, x)     // Accesses the entire bucket structure at index 'x'.
kh_key(h, x)        // Accesses the 'key' field of the bucket at index 'x'.
kh_size(h)          // Returns the number of elements in the hash table.
kh_capacity(h)      // Returns the total number of buckets (including empty ones).
kh_end(h)           // Returns the sentinel value for "not found" or "end of iteration" (i.e., kh_capacity(h)).
kh_exist(h, x)      // Checks if the bucket at index 'x' is occupied (1 if used, 0 otherwise).
kh_foreach(h, x)    // Iterates through all *existing* elements in hash table 'h', setting 'x' to the index.
*/

